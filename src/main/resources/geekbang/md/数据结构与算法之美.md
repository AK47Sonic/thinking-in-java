## 数据结构与算法之美

#### 复杂度分析
1. 大 O 复杂度表示法T(n) = O(n)
    - T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。
    ```text
     int cal(int n) {
       int sum = 0;
       int i = 1;
       for (; i <= n; ++i) {
         sum = sum + i;
       }
       return sum;
     }
    ```
    时间复杂度： T(n) = O(n)
    
    ```text
     int cal(int n) {
       int sum = 0;
       int i = 1;
       int j = 1;
       for (; i <= n; ++i) {
         j = 1;
         for (; j <= n; ++j) {
           sum = sum +  i * j;
         }
       }
     }
    ```
    时间复杂度： T(n) = O(n²)
    
    ```text
     i=1;
     while (i <= n)  {
       i = i * 2;
     }
    ```
    时间复杂度： T(n) = O(logn)

2. 时间复杂度分析（渐进时间复杂度）

    - 只关注循环执行次数最多的一段代码
    ```text
            int cal(int n) {
              int sum = 0;
              int i = 1;
              for (; i <= n; ++i) {
                sum = sum + i;
              }
              return sum;
            }
    ```
    时间复杂度： T(n) = O(n)
    
    - 加法法则：总复杂度等于量级最大的那段代码的复杂度
    ```text
    int cal(int n) {
       int sum_1 = 0;
       int p = 1;
       for (; p < 100; ++p) {
         sum_1 = sum_1 + p;
       }
    
       int sum_2 = 0;
       int q = 1;
       for (; q < n; ++q) {
         sum_2 = sum_2 + q;
       }
     
       int sum_3 = 0;
       int i = 1;
       int j = 1;
       for (; i <= n; ++i) {
         j = 1; 
         for (; j <= n; ++j) {
           sum_3 = sum_3 +  i * j;
         }
       }
     
       return sum_1 + sum_2 + sum_3;
     }
    ```
    时间复杂度： T(n) = O(n²)
    
    - 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
    ```text
    int cal(int n) {
       int ret = 0; 
       int i = 1;
       for (; i < n; ++i) {
         ret = ret + f(i);
       } 
     } 
     
     int f(int n) {
      int sum = 0;
      int i = 1;
      for (; i < n; ++i) {
        sum = sum + i;
      } 
      return sum;
     }
    ```
    时间复杂度： T(n) = O(n²)
    
3. 常见时间复杂度
    - 多项式量级
    - 非多项式量级：O(2^n) 和 O(n!), 当数据规模n越来越大时，非多项式量级算法的执行时间会急剧增加，所以非多项式时间复杂度的算法是非常低效的算法。
    
4. 空间复杂度分析（渐进空间复杂度）
    ```text
    void print(int n) {
      int i = 0;
      int[] a = new int[n];
      for (i; i <n; ++i) {
        a[i] = i * i;
      }
    
      for (i = n-1; i >= 0; --i) {
        print out a[i]
      }
    }
    ```
    空间复杂度： S(n) = O(n)
    
5. 总结:

    ![常见时间复杂度](../pic/常见时间复杂度.JPG)  
    
    ![时间复杂度函数](../pic/复杂度函数.JPG)  

6. 四个复杂度分析方法
    ```text
    // n 表示数组 array 的长度
    int find(int[] array, int n, int x) {
      int i = 0;
      int pos = -1;
      for (; i < n; ++i) {
        if (array[i] == x) {
           pos = i;
           break;
        }
      }
      return pos;
    }
    ```
    - 最好情况时间复杂度<br/>
      在最理想的情况下，执行这段代码的时间复杂度O(1)
    - 最坏情况时间复杂度<br/>
       在最糟糕的情况下，执行这段代码的时间复杂度O(n)
    - 平均情况时间复杂度（加权平均时间复杂度） 
     ![加权平均时间复杂度](../pic/加权平均时间复杂度.JPG) 
    - 均摊时间复杂度<br/>
    对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高的时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。
    
#### 数组

1. 定义
<br/>数组是一种线性表数据结构，他用一组连续的内存空间，来存储一组具有相同类型的数据。

2. 线性表
    - 数组
    - 链表
    - 队列
    - 栈
    ![线性表](../pic/线性表.JPG)

3. 非线性表
    - 二叉树
    - 堆
    - 图
    ![非线性表](../pic/非线性表.JPG)

4. 寻址
<br/>a[i]_address = base_address + i * data_type_size
<br/>a是数组首地址，i是偏移量

5. 盲点
<br/>数组查找的时间复杂度不是O(1)，即使是有序数组通过二分查找也需要O(logn), 是根据下标随机访问时间复杂度为O(1)

6. 下标随机访问时间复杂度
    - O(1)
    
7. 插入时间复杂度
    - 最好时间复杂度：O(1)
    - 最坏时间复杂度：O(n)
    - 平均时间复杂度：O(n)

8. 提高第K个位置插入效率 
    - 把第K个位置的数据放到最后
    ![插入](../pic/数组插入.JPG)

9. 删除时间复杂度
    - 最好时间复杂度：O(1)
    - 最坏时间复杂度：O(n)
    - 平均时间复杂度：O(n)

10. 提高删除效率
    - 把删除的数据先标记，等数组满了后，一次性删除
    ![删除](../pic/数组删除.JPG)
    
11. ArrayList VS Array
    - ArrayList最大的优势就是可以将很多数组操作的细节封装起来，并支持动态扩容，每次存储空间不够的时候，空间自动扩容1.5倍
    - 最好在创建的ArrayList的时候实现指定数据大小，防止动态扩容
    - 数组的优势在于支持基本类型，ArrayList的Autoboxing，Unboxing都有性能消耗

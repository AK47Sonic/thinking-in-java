## 并发编程之美

### 线程和进程
进程是系统进行资源分配和调度的基本单位， 线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。操作系统在分配资源时是把资源分配给进程的， 但是CPU 资源比较特殊， 它是被分配到线程的， 因为真正要占用CPU 运行的是线程， 所以也说线程是CPU 分配的基本单位。在Java 中，当我们启动main 函数时其实就启动了一个JVM的进程， 而main 函数所在的线程就是这个进程中的一个线程，也称主线程。

### 程序计数器
程序计数器是一块内存区域，用来记录线程当前要执行的指令地址。程序计数器就是为了记录该线程让出CPU 时的执行地址的，待再次分配到时间片时线程就可以从自己私有的计数器指定地址继续执行。另外需要注意的是，如果执行的是native 方法，那么pc 计数器记录的是undefined 地址，只有执行的是Java 代码时pc 计数器记录的才是下一条指令的地址。

### 栈
每个线程都有自己的占资源，用于存储该线程的局部变量，这些局部变量是该线程私有的，其他线程是访问不了的，除此之外枝还用来存放线程的调用技帧。

### 堆
堆是一个进程中最大的一块内存，堆是被进程中的所有线程共享的，是进程创建时分配的，堆里面主要存放使用new 操作创建的对象实例。

### 方法区
方法区则用来存放NM 加载的类、常量及静态变量等信息，也是线程共享的。

### 创建线程的3种方式
- Thread
- Runnable
- FutureTask implements RunnableFuture, 通过get方法可以拿到返回值
    - FutureTask(Callable<V> callable) 
    - FutureTask(Runnable runnable, V result)


### Callable VS Runnable
- Runnable中run没有返回值，不能抛异常
- Callable中call有返回值，能抛异常

### wait()
- 调用线程会被阻塞挂起，直到其他线程调用了该共享对象的notify()或者notifyAll()方法
- 调用线程会被阻塞挂起，直到调用了该线程的interrupt()方法， 该线程抛出InterruptedException异常返回。
- 如果调用wait()方法的线程没有事先获取该对象的监视器锁，则调用wait()方法时调用线程会抛出IllegalMonitorStateException异常。
- 每个线程可以有多个监视器锁(obj1,obj2,obj3), 当前线程调用共享变量obj1的wait()方法后只会释放当前共享变量obj1上的锁，如果当前线程还持有其他共享变量(obj2,obj3)的锁，则这些锁是不会被释放的。

### 虚假唤醒
-  该线程没有被其他线程调用notify()、notifyAll()方法进行通知，或者被中断，或者等待超时，但这个线程从挂起状态变为可以运行状态（也就是被唤醒），这就是虚假唤醒。
- 虽然虚假唤醒在应用实践中很少发生，但要防患于未然，做法就是不停地去测试该线程被唤醒的条件是否满足，不满足则继续等待，也就是说在一个循环中调用wait()方法进行防范。
```text
synchronized（obj) {
while（条件不满足)
obj.wait() ;
}
```

### 解决死锁（打破持有并等待原则）
- 一个线程同时获取A,B资源，才执行。
- 一个线程获取到A资源，如果在获取B资源失败，则放弃A资源。
- 不同线程保持相同的顺序去获取资源，即都是A->B。






## 并发编程之美

### 线程和进程
进程是系统进行资源分配和调度的基本单位， 线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。操作系统在分配资源时是把资源分配给进程的， 但是CPU 资源比较特殊， 它是被分配到线程的， 因为真正要占用CPU 运行的是线程， 所以也说线程是CPU 分配的基本单位。在Java 中，当我们启动main 函数时其实就启动了一个JVM的进程， 而main 函数所在的线程就是这个进程中的一个线程，也称主线程。

### 程序计数器
程序计数器是一块内存区域，用来记录线程当前要执行的指令地址。程序计数器就是为了记录该线程让出CPU 时的执行地址的，待再次分配到时间片时线程就可以从自己私有的计数器指定地址继续执行。另外需要注意的是，如果执行的是native 方法，那么pc 计数器记录的是undefined 地址，只有执行的是Java 代码时pc 计数器记录的才是下一条指令的地址。

### 栈
每个线程都有自己的占资源，用于存储该线程的局部变量，这些局部变量是该线程私有的，其他线程是访问不了的，除此之外枝还用来存放线程的调用技帧。

### 堆
堆是一个进程中最大的一块内存，堆是被进程中的所有线程共享的，是进程创建时分配的，堆里面主要存放使用new 操作创建的对象实例。

### 方法区
方法区则用来存放NM 加载的类、常量及静态变量等信息，也是线程共享的。

### 创建线程的3种方式
- Thread
- Runnable
- FutureTask implements RunnableFuture, 通过get方法可以拿到返回值
    - FutureTask(Callable<V> callable) 
    - FutureTask(Runnable runnable, V result)


### Callable VS Runnable
- Runnable中run没有返回值，不能抛异常
- Callable中call有返回值，能抛异常

### wait()
- 调用线程会被阻塞挂起，直到其他线程调用了该共享对象的notify()或者notifyAll()方法
- 调用线程会被阻塞挂起，直到调用了该线程的interrupt()方法， 该线程抛出InterruptedException异常返回。
- 如果调用wait()方法的线程没有事先获取该对象的监视器锁，则调用wait()方法时调用线程会抛出IllegalMonitorStateException异常。
- 每个线程可以有多个监视器锁(obj1,obj2,obj3), 当前线程调用共享变量obj1的wait()方法后只会释放当前共享变量obj1上的锁，如果当前线程还持有其他共享变量(obj2,obj3)的锁，则这些锁是不会被释放的。
- wait()底层调用wait(0), wait(long timeout)到超时时间，自动返回。

### notify()
- 一个线程调用共享对象的notify()方法后，会唤醒一个在该共享变量上调用wait系列方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。
- 被唤醒的线程不能马上从wait 方法返回并继续执行，它必须在获取了共享对象的监视器锁后才可以返回也就是唤醒它的线程释放了共享变量上的监视器锁后，被唤醒的线程也不一定会获取到共享对象的监视器锁，这是因为该线程还需要和其他线程一起竞争该锁，只有该线程竞争到了共享变量的监视器锁后才可以继续执行。
- 只有当前线程获取到了共享变量的监视器锁后, 才可以调用共享变量的notify()方法，否则会抛出IllegalMonitorStateException 异常。
- 线程A首先获取resourceA 上面的锁，然后调用resourceA 的wait（）方法挂起当前线程并释放获取到的锁，然后线程B获取到resourceA 上的锁井调用resourceA 的wait（）方法，此时线程B 也被阻塞挂起并释放了resourceA 上的锁，到这里线程A 和钱程B 都被放到了resourceA 的阻塞集合里面。线程C 休眠结束后在共享资源resourceA 上调用了notify（） 方法，这会激活resourceA 的阻塞集合里面的一个线程，这里激活了线程A，所以线程A 调用的wait()方法返回了，线程A 执行完毕。而线程B 还处于阻塞状态。

### notifyAll()
- 不同于在共享变量上调用notify()函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用wait 系列方法而被挂起的线程。
- 在共享变量上调用notifyAll（）方法只会唤醒调用这个方法前调用了wait 系列函数而被放入共享变量等待集合里面的线程。如果调用notifyA ll（）方法后一个线程调用了该共享变量的wait（）方法而被放入阻塞集合， 则该线程是不会被唤醒的。

### 虚假唤醒
-  该线程没有被其他线程调用notify()、notifyAll()方法进行通知，或者被中断，或者等待超时，但这个线程从挂起状态变为可以运行状态（也就是被唤醒），这就是虚假唤醒。
- 虽然虚假唤醒在应用实践中很少发生，但要防患于未然，做法就是不停地去测试该线程被唤醒的条件是否满足，不满足则继续等待，也就是说在一个循环中调用wait()方法进行防范。
```text
synchronized（obj) {
while（条件不满足)
obj.wait() ;
}
```

### sleep()
- 调用线程会暂时让出指定时间的CPU执行权，也就是在这期间不参与CPU 的调度，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。
- 如果在睡眠之前或者期间，其他线程调用了该线程的interrupt（）方法中断了该线程，则该线程会在调用sleep 方法的地方抛出InterruptedException 异常而返回。

### 解决死锁（打破持有并等待原则）
- 一个线程同时获取A,B资源，才执行。
- 一个线程获取到A资源，如果在获取B资源失败，则放弃A资源。
- 不同线程保持相同的顺序去获取资源，即都是A->B。

### join()
- 使用场景：需要等待多个线程全部加载完毕再汇总处理。
- **在线程A中调用B.join(), 线程A等线程B执行完成, 如果要中断线程A，需要调用A.interrupt(), 而不是B.interrupt()。**

### Thread类的静态方法
- currentThread()
- yield()
- sleep()








